{{- $alt := .PlainText | safeHTML -}}
{{- $lazyLoading := .Page.Site.Params.enableImageLazyLoading | default true -}}
{{- $dest := .Destination -}}

{{- $isLocal := not (urls.Parse $dest).Scheme -}}
{{- $isPage := and (eq .Page.Kind "page") (not .Page.BundleType) -}}
{{- $startsWithSlash := hasPrefix $dest "/" -}}
{{- $startsWithRelative := hasPrefix $dest "../" -}}

{{- if and $dest $isLocal -}}
  {{- if $startsWithSlash -}}
    {{/* Images under static directory */}}
    {{- $dest = (relURL (strings.TrimPrefix "/" $dest)) -}}
  {{- else if and $isPage (not $startsWithRelative) -}}
    {{/* Images that are sibling to the individual page file */}}
    {{ $dest = (printf "../%s" $dest) }}
  {{- end -}}
{{- end -}}



<figure class="image-container">
{{- with .Title -}}
    <img src="{{ $dest | safeURL }}" alt="{{ $alt }}" {{ if $lazyLoading }}loading="lazy"{{ end }} />
    <figcaption class="caption" data-caption="{{ . }}"></figcaption>
{{- else -}}
    <img src="{{ $dest | safeURL }}" alt="{{ $alt }}" {{ if $lazyLoading }}loading="lazy"{{ end }} />
{{- end -}}
</figure>


<style>
  .image-container {
    position: relative;
    display: inline-block;
    cursor: pointer;
  }

  .caption {
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    text-align: center;
    padding: 5px;
    margin-bottom: 15px;
    opacity: 0; /* Hide the caption by default */
    transition: opacity 0.3s ease;
    visibility: hidden; /* Hide the caption from the page preview */
  }

  .image-container:hover .caption {
    opacity: 1; /* Show the caption on hover */
    visibility: visible; /* Make the caption visible on hover */
  }
</style>

<script>

  document.addEventListener("DOMContentLoaded", () => {
    const images = [...document.querySelectorAll(".image-container img")]; // Ensure it's an array
    let currentIndex = 0;
    let overlay;

    function initCaptionHover() {
      document.querySelectorAll(".image-container").forEach(container => {
        const caption = container.querySelector(".caption");
        container.addEventListener("mouseenter", () => caption.textContent = caption.dataset.caption);
        container.addEventListener("mouseleave", () => caption.textContent = "");
      });
    }
  
    function createFullscreenOverlay() {
      if (document.querySelector(".fullscreen-overlay")) return; // Prevent duplicates
  
      document.body.insertAdjacentHTML('beforeend', `
        <div class="fullscreen-overlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.9); display:flex; justify-content:center; align-items:center; flex-direction:column; z-index:1000;">
          <span class="close-btn" style="position:absolute; top:20px; right:20px; color:white; font-size:30px; cursor:pointer;">&times;</span>
          <span class="prev-btn" style="position:absolute; top:50%; left:20px; transform:translateY(-50%); color:white; font-size:30px; cursor:pointer;">&#10094;</span>
          <span class="next-btn" style="position:absolute; top:50%; right:20px; transform:translateY(-50%); color:white; font-size:30px; cursor:pointer;">&#10095;</span>
          <img class="fullscreen-image" style="max-width:90%; max-height:90%;" />
          <div class="fullscreen-caption" style="position:absolute; bottom:20px; color:white; background:rgba(0,0,0,0.9); padding:10px; font-size:18px; text-align:center; width:90%;"></div>
        </div>
      `);
  
      overlay = document.querySelector(".fullscreen-overlay");
      overlay.style.display = "none";

      // Close the overlay if clicking on the background (empty area)
      overlay.addEventListener("click", (e) => {
      if (e.target === overlay) {  // Only close if the click was on the empty area
        hideOverlay();
        }
      });

      // Add touch event listeners for mobile swipe functionality
      overlay.addEventListener("touchstart", handleTouchStart, { passive: true });
      overlay.addEventListener("touchend", handleTouchEnd, { passive: true });
    }
  
    function showOverlay(index) {
      if (!images[index]) return;
  
      currentIndex = index;
      const fullscreenImage = overlay.querySelector(".fullscreen-image");
      const fullscreenCaption = overlay.querySelector(".fullscreen-caption");
  
      fullscreenImage.src = images[currentIndex].src;
      const captionElement = images[currentIndex].closest(".image-container").querySelector(".caption");
      fullscreenCaption.textContent = captionElement ? captionElement.dataset.caption : "";
  
      overlay.style.display = "flex";
      document.body.style.overflow = "hidden"; // Disable scroll
      document.addEventListener("keydown", handleKeyPress);
    }
  
    function hideOverlay() {
      overlay.style.display = "none";
      document.body.style.overflow = ""; // Enable scroll
      document.removeEventListener("keydown", handleKeyPress);
    }
  
    function handleKeyPress(e) {
      if (e.key === "ArrowLeft") navigate(-1);
      if (e.key === "ArrowRight") navigate(1);
      if (e.key === "Escape") hideOverlay();
    }
  
    function navigate(direction) {
      const newIndex = (currentIndex + direction + images.length) % images.length;
      showOverlay(newIndex);
    }

    function handleTouchStart(e) {
      // Track the touch start position
      touchStartX = e.touches[0].clientX;
    }
  
    function handleTouchEnd(e) {
      const touchEndX = e.changedTouches[0].clientX;
  
      // If swiped right (touchStartX < touchEndX), go to the previous image
      if (touchStartX - touchEndX > 50) {
        navigate(1); // Next image
      }
      // If swiped left (touchStartX > touchEndX), go to the next image
      if (touchEndX - touchStartX > 50) {
        navigate(-1); // Previous image
      }
    }
  
    function initFullscreenSlideshow() {
      createFullscreenOverlay();
      overlay = document.querySelector(".fullscreen-overlay");
      const closeBtn = overlay.querySelector(".close-btn");
      const prevBtn = overlay.querySelector(".prev-btn");
      const nextBtn = overlay.querySelector(".next-btn");
  
      images.forEach((img, index) => {
        img.addEventListener("click", () => showOverlay(index));
      });
  
      closeBtn.addEventListener("click", hideOverlay);
      prevBtn.addEventListener("click", () => navigate(-1));
      nextBtn.addEventListener("click", () => navigate(1));

      overlay.addEventListener("click", (e) => {
        if (e.target === overlay) {  // Only close if the click was on the empty area
          hideOverlay();
        }
      });
    }
  
    const observer = new IntersectionObserver(entries => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          initCaptionHover();
          initFullscreenSlideshow();
          observer.unobserve(entry.target);
        }
      });
    });
  
    document.querySelectorAll(".image-container").forEach(container => observer.observe(container));
  });
  
</script>